{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-kube-burner","title":"What is Kube-burner","text":"<p>Kube-burner is a Kubernetes performance toolset. It provides multiple functionalities where the most hightliged can be summarized in:</p> <ul> <li>Create, delete and patch Kubernetes at scale.</li> <li>Prometheus metric collection and indexing.</li> <li>Measurements.</li> <li>Alerting.</li> </ul> <p>Kube-burner is a binary application written in golang that makes an intensive usage of the official k8s client library, client-go.</p> <p></p>"},{"location":"#quick-starting-with-kube-burner","title":"Quick starting with Kube-burner","text":"<p>In case you want to start tinkering with Kube-burner now:</p> <ul> <li>Find binaries for different CPU architectures and operating systems in the releases section of the repository.</li> <li>There's also a container image repository available at quay.</li> <li>Some valid examples of configuration files, metrics profiles and grafana dashboards can be found in the examples directory of the repository.</li> </ul>"},{"location":"cli/","title":"CLI","text":"<p>kube-burner is a tool written in golang that can be used to stress kubernetes clusters by creating, deleting and patching resources at a given rate. The actions taken by this tool are highly customizable and their available subcommands are detailed below:</p> <pre><code>$ kube-burner help\nKube-burner \ud83d\udd25\n\nTool aimed at stressing a kubernetes cluster by creating or deleting lots of objects.\n\nUsage:\n  kube-burner [command]\n\nAvailable Commands:\n  check-alerts Evaluate alerts for the given time range\n  completion   Generates completion scripts for bash shell\n  destroy      Destroy old namespaces labeled with the given UUID.\n  help         Help about any command\n  import       Import metrics tarball\n  index        Index kube-burner metrics\n  init         Launch benchmark\n  version      Print the version number of kube-burner\n\nFlags:\n  -h, --help   help for kube-burner\n  --log-level string   Allowed values: debug, info, warn, error, fatal (default \"info\")\n\nUse \"kube-burner [command] --help\" for more information about a command.\n</code></pre>"},{"location":"cli/#init","title":"Init","text":"<p>This is the main subcommand, it triggers a new kube-burner benchmark and it supports the these flags:</p> <ul> <li><code>uuid</code>: Benchmark ID. This is esentially an arbitrary string that is used for different purposes along the benchmark. For example, label the objects created by kube-burner as mentioned in the reference chapter. By default is autogenerated.</li> <li><code>config</code>: Path or URL to a valid configuration file. Details about configuration schema in the reference chapter.</li> <li><code>configmap</code>: In case of not providing the <code>--config</code> flag, kube-burner is able to fetch its configuration from a given <code>configMap</code>, this variable configures its name, kube-burner expects the configMap to hold all the required configuration: config.yml, metrics.yml and alerts.yml. Where metrics.yml and alerts.yml are optional.</li> <li><code>namespace</code>: Name of namespace where the configmap is.</li> <li><code>log-level</code>: Logging level, one of: <code>debug</code>, <code>error</code>, <code>info</code> or <code>fatal</code>. Default <code>info</code>.</li> <li><code>prometheus-url</code>: Prometheus endpoint, required for metrics collection. i.e. <code>https://prometheus-k8s-openshift-monitoring.apps.rsevilla.stress.mycluster.example.com</code></li> <li><code>metrics-profile</code>: Path to a valid metrics profile file. Default <code>metrics.yml</code></li> <li><code>metrics-endpoint</code>: Path to a valid metrics endpoint file.</li> <li><code>token</code>: Prometheus Bearer token.</li> <li><code>username</code>: Prometheus username for basic authentication.</li> <li><code>password</code>: Prometheus password for basic authentication.</li> <li><code>skip-tls-verify</code>: Skip TLS verification for prometheus. Default <code>true</code></li> <li><code>step</code>: Prometheus step size. Default <code>30s</code></li> <li><code>timeout</code>: Kube-burner benchmark global timeout. When timing out, return code is 2. Default <code>4h</code></li> <li><code>user-metadata</code>: YAML file path containing custom user-metadata to be indexed.</li> </ul> <p>Prometheus authentication</p> <p>Both basic and token authentication methods need permissions able to query the given Prometheus endpoint.</p> <p>With the above, running a kube-burner benchmark would be as simple as:</p> <pre><code>kube-burner init -c cfg.yml -u https://prometheus-k8s-openshift-monitoring.apps.rsevilla.stress.mycluster.example.com -t ${token} --uuid 67f9ec6d-6a9e-46b6-a3bb-065cde988790`\n</code></pre> <p>Kube-burner also supports remote configuration files served by a web server, to use it, rather than a path pass a URL like below:</p> <pre><code>kube-burner init -c http://web.domain.com:8080/cfg.yml -t ${token} --uuid 67f9ec6d-6a9e-46b6-a3bb-065cde988790`\n</code></pre> <p>To scrape metrics from multiple endpoints init command can be triggered as below.</p> <pre><code>kube-burner init -c cluster-density.yml -e metrics-endpoints.yaml\n</code></pre> <p>And a metrics-endpoints.yaml file with valid keys for the <code>init</code> command would look something like this.</p> <pre><code>- endpoint: http://localhost:9090\ntoken: &lt;token&gt;\nprofile: metrics.yaml\nalertProfile: alert-profile.yaml\n- endpoint: http://remotehost:9090\ntoken: &lt;token&gt;\n</code></pre> <p>Note</p> <p>Options <code>profile</code> and <code>alertProfile</code> are optional. If not provided will be taken from the CLI flags first or else will be populated with the default values. And also apart from valid keys rest all will be ignored.</p>"},{"location":"cli/#index","title":"Index","text":"<p>This subcommand can be used to collect and index the metrics from a given time range. The time range is given by:</p> <ul> <li><code>start</code>: Epoch start time. Defaults to one hour before the current time.</li> <li><code>end</code>: Epoch end time. Defaults to the current time.</li> </ul>"},{"location":"cli/#check-alerts","title":"Check alerts","text":"<p>This subcommand can be used to evaluate alerts configured in the given alert profile. Similar to <code>index</code> the time range is given by the <code>start</code> and <code>end</code> flags.</p>"},{"location":"cli/#destroy","title":"Destroy","text":"<p>This subcommand requires the <code>uuid</code> flag to destroy all namespaces labeled with <code>kube-burner-uuid=&lt;UUID&gt;</code>.</p>"},{"location":"cli/#completion","title":"Completion","text":"<p>Generates bash a completion script that can be imported with: <code>. &lt;(kube-burner completion)</code></p> <p>Or permanently imported with: <code>kube-burner completion &gt; /etc/bash_completion.d/kube-burner</code></p> <p>Note</p> <p>the <code>bash-completion</code> utils must be installed in order to kube-burner's completion to work</p>"},{"location":"measurements/","title":"Measurements","text":"<p>Kube-burner allows to get further metrics using other mechanisms or data sources such as the own kubernetes API, these mechanisms are called measurements.</p> <p>Measurements are enabled in the measurements section of the configuration file. This section contains a list of measurements with their options. 'kube-burner' supports the following measurements so far:</p> <p>Warning</p> <p><code>podLatency</code>, as any other measurement, is only captured during a benchmark runtime. It does not work with the <code>index</code> subcommand of kube-burner</p>"},{"location":"measurements/#pod-latency","title":"Pod latency","text":"<p>Collects latencies from the different pod startup phases, these latency metrics are in ms. Can be enabled with:</p> <pre><code>  measurements:\n- name: podLatency\n</code></pre> <p>This measurement sends its metrics to configured indexer. The metrics collected are pod latency histograms and pod latency quantiles P99, P95 and P50.</p> <p>Pod latency sample:</p> <pre><code>{\n\"timestamp\": \"2020-11-15T20:28:59.598727718Z\",\n\"schedulingLatency\": 4,\n\"initializedLatency\": 20,\n\"containersReadyLatency\": 2997,\n\"podReadyLatency\": 2997,\n\"metricName\": \"podLatencyMeasurement\",\n\"jobName\": \"kubelet-density\",\n\"uuid\": \"c40b4346-7af7-4c63-9ab4-aae7ccdd0616\",\n\"namespace\": \"kubelet-density\",\n\"podName\": \"kubelet-density-13\",\n\"jobName\": \"kube-burner-job\",\n\"nodeName\": \"worker-001\"\n}\n</code></pre> <p>Pod latency quantile sample:</p> <pre><code>{\n\"quantileName\": \"Ready\",\n\"uuid\": \"23c0b5fd-c17e-4326-a389-b3aebc774c82\",\n\"P99\": 3774,\n\"P95\": 3510,\n\"P50\": 2897,\n\"max\": 3774,\n\"avg\": 2876.3,\n\"timestamp\": \"2020-11-15T22:26:51.553221077+01:00\",\n\"metricName\": \"podLatencyQuantilesMeasurement\",\n\"jobName\": \"kubelet-density\"\n},\n{\n\"quantileName\": \"PodScheduled\",\n\"uuid\": \"23c0b5fd-c17e-4326-a389-b3aebc774c82\",\n\"P99\": 64,\n\"P95\": 8,\n\"P50\": 5,\n\"max\": 64,\n\"avg\": 5.38,\n\"timestamp\": \"2020-11-15T22:26:51.553225151+01:00\",\n\"metricName\": \"podLatencyQuantilesMeasurement\",\n\"jobName\": \"kubelet-density\"\n}\n</code></pre> <p>Where quantileName matches with the pod conditions and can be:</p> <ul> <li><code>PodScheduled</code>: Pod has been scheduled in to a node.</li> <li><code>Initialized</code>: All init containers in the pod have started successfully</li> <li><code>ContainersReady</code>: Indicates whether all containers in the pod are ready.</li> <li><code>Ready</code>: The pod is able to service reqeusts and should be added to the load balancing pools of all matching services.</li> </ul> <p>Info</p> <p>More information about the pod conditions can be found at the kubernetes documentation site.</p> <p>And the metrics are:</p> <ul> <li><code>P99</code>: 99th percentile of the pod condition.</li> <li><code>P95</code>: 95th percentile of the pod condition.</li> <li><code>P50</code>: 50th percentile of the pod condition.</li> <li><code>Max</code>: Maximum value of the condition.</li> <li><code>Avg</code>: Average value of the condition.</li> </ul>"},{"location":"measurements/#pod-latency-thresholds","title":"Pod latency thresholds","text":"<p>It's possible to establish pod latency thresholds to the different pod conditions and metrics by defining the option <code>thresholds</code> within this measurement:</p> <p>Establishing a threshold of 2000ms in the P99 metric of the <code>Ready</code> condition.</p> <pre><code>      measurements:\n- name: podLatency\nthresholds:\n- conditionType: Ready\nmetric: P99\nthreshold: 2000ms\n</code></pre> <p>Latency thresholds are evaluated at the end of each job, showing an informative message like the following:</p> <pre><code>INFO[2020-12-15 12:37:08] Evaluating latency thresholds\nWARN[2020-12-15 12:37:08] P99 Ready latency (2929ms) higher than configured threshold: 2000ms\n</code></pre> <p>In case of not meeting any of the configured thresholds, like the example above, kube-burner return code will be 1.</p>"},{"location":"measurements/#pprof-collection","title":"pprof collection","text":"<p>This measurement can be used to collect golang profiling information from processes running in pods from the cluster. To do so, kube-burner connects to pods labeled with <code>labelSelector</code> and running in <code>namespace</code>. This measurement uses an implementation similar to <code>kubectl exec</code>, and as soon as it connects to one pod it executes the command <code>curl &lt;pprofURL&gt;</code> to get the pprof data. pprof files are collected in a regular basis configured by the parameter <code>pprofInterval</code>, the collected pprof files are downloaded from the pods to the local directory configured by the parameter <code>pprofDirectory</code> which by default is <code>pprof</code>.</p> <p>As some components require authentication to get profiling information, <code>kube-burner</code> provides two different modalities to address it:</p> <ul> <li>Bearer token authentication: This modality is configured by the variable <code>bearerToken</code>, which holds a valid Bearer token that will be used by cURL to get pprof data. This method is usually valid with kube-apiserver and kube-controller-managers components</li> <li>Certificate Authentication: Usually valid for etcd, this method can be configured using a combination of cert/privKey files or directly using the cert/privkey content, it can be tweaked with the following variables:<ol> <li><code>cert</code>: Base64 encoded certificate.</li> <li><code>key</code>: Base64 encoded private key.</li> <li><code>certFile</code>: Path to a certificate file.</li> <li><code>keyFile</code>: Path to a private key file.</li> </ol> </li> </ul> <p>Note</p> <p>The decoded content of the certificate and private key is written to the files /tmp/pprof.crt and /tmp/pprof.key of the remote pods respectively</p> <p>An example of how to configure this measurement to collect pprof HEAP and CPU profiling data from kube-apiserver and etcd is shown below:</p> <pre><code>   measurements:\n- name: pprof\npprofInterval: 30m\npprofDirectory: pprof-data\npprofTargets:\n- name: kube-apiserver-heap\nnamespace: \"openshift-kube-apiserver\"\nlabelSelector: {app: openshift-kube-apiserver}\nbearerToken: thisIsNotAValidToken\nurl: https://localhost:6443/debug/pprof/heap\n\n- name: etcd-heap\nnamespace: \"openshift-etcd\"\nlabelSelector: {app: etcd}\ncertFile: etcd-peer-pert.crt\nkeyFile: etcd-peer-pert.key\nurl: https://localhost:2379/debug/pprof/heap\n</code></pre> <p>Warning</p> <p>As mentioned before, this measurement requires the <code>curl</code> command to be available in the target pods.</p>"},{"location":"ocp/","title":"OpenShift Wrapper","text":"<p>The kube-burner binary brings a very opinionated OpenShift wrapper designed to simplify the execution of different workloads in this kubernetes distribution. This wrapper is hosted under the <code>kube-burner ocp</code> subcommand that currently looks like:</p> <pre><code>$ kube-burner ocp help\nThis subcommand is meant to be used against OpenShift clusters and serve as a shortcut to trigger well-known workloads\n\nUsage:\n  kube-burner ocp [command]\n\nAvailable Commands:\n  cluster-density    Runs cluster-density workload\n  cluster-density-ms Runs cluster-density-ms workload\n  cluster-density-v2 Runs cluster-density-v2 workload\n  node-density       Runs node-density workload\n  node-density-cni   Runs node-density-cni workload\n  node-density-heavy Runs node-density-heavy workload\n\nFlags:\n      --alerting                  Enable alerting (default true)\n      --burst int                 Burst (default 20)\n      --es-index string           Elastic Search index\n      --es-server string          Elastic Search endpoint\n      --extract                   Extract workload in the current directory\n      --gc                        Garbage collect created namespaces (default true)\n  -h, --help                      help for ocp\n      --local-indexing            Enable local indexing\n      --metrics-endpoint string   YAML file with a list of metric endpoints\n      --qps int                   QPS (default 20)\n      --timeout duration          Benchmark timeout (default 3h0m0s)\n      --user-metadata string      User provided metadata file, in YAML format\n      --uuid string               Benchmark UUID (default \"d18989c4-4f8a-4a14-b711-9afae69a9140\")\n\nGlobal Flags:\n      --log-level string   Allowed values: debug, info, warn, error, fatal (default \"info\")\n\nUse \"kube-burner ocp [command] --help\" for more information about a command.\n</code></pre>"},{"location":"ocp/#usage","title":"Usage","text":"<p>In order to trigger one of the supported workloads using this subcommand you have to run kube-burner using the subcommand ocp. The workloads are embed in the kube-burner binary:</p> <p>Running node-density with 100 pods per node</p> <pre><code>kube-burner ocp node-density --pods-per-node=100\n</code></pre> <p>Running cluster-density with multiple endpoints support</p> <pre><code>kube-burner ocp cluster-density --iterations=1 --churn-duration=2m0s --es-index kube-burner --es-server https://www.esurl.com:443 --metrics-endpoint metrics-endpoints.yaml\n</code></pre> <p>With the command above, the wrapper will calculate the required number of pods to deploy across all worker nodes of the cluster.</p> <p>This wrapper provides the following benefits among others:</p> <ul> <li>Provides a simplified execution of the supported workloads</li> <li>Indexes OpenShift metadata along with the Benchmark result, this document can be found with the following query: <code>uuid: &lt;benchmkark-uuid&gt; AND metricName.keyword: \"clusterMetadata\"</code></li> <li>Prevents modifying configuration files to tweak some of the parameters of the workloads</li> <li>Discovers the Prometheus URL and authentication token, so the user does not have to perform those operations before using them.</li> </ul>"},{"location":"ocp/#cluster-density-workloads","title":"Cluster density workloads","text":"<p>This workload family is a control-plane density focused workload that that creates different objects across the cluster. There're 3 different variants cluster-density, cluster-density-v2 and cluster-density-ms.</p> <p>Each iteration of these create a new namespace, the three support similar configuration flags. Check them out from the subcommand help</p> <p>Info</p> <p>Workload churning of 1h is enabled by default in the <code>cluster-density</code> workloads, you can disable it by passing <code>--churn=false</code> to the workload subcommand</p>"},{"location":"ocp/#cluster-density","title":"cluster-density","text":"<p>Each iteration of cluster-density creates the following objects in each of the dreated namespaces:</p> <ul> <li>1 Imagestream</li> <li>1 Build. The OCP internal container registry must be set-up previously since the resulting container image will be pushed there.</li> <li>5 Deployments with two pod replicas (pause) mounting 4 secrets, 4 configmaps and 1 downwardAPI volume each</li> <li>5 Services, each one pointing to the TCP/8080 and TCP/8443 ports of one of the previous deployments</li> <li>1 edge Route pointing to the to first service</li> <li>10 Secrets containing 2048 character random string</li> <li>10 ConfigMaps containing a 2048 character random string</li> </ul>"},{"location":"ocp/#cluster-density-v2","title":"cluster-density-v2","text":"<p>Very similar to cluster-density, but with some key differences provided by NetworkPolicies and improved readinessProbes, that leads to a heavier load in the cluster's CNI plugin. Each iteration creates the following objects in each of the created namespaces:</p> <ul> <li>1 ImagesStream</li> <li>1 Build. The OCP internal container registry must be set-up previously since the resulting container image will be pushed there.</li> <li>3 Deployments with two pod 2 replicas (nginx) mounting 4 Secrets, 4 configmaps and 1 downwardAPI volume each</li> <li>2 Deployments with two pod 2 replicas (curl) mounting 4 Secrets, 4 configmaps and 1 downwardAPI volume each. These pods have configured a readinessProbe that makes a request to one of the Services and one of the routes created by this workload every 10 seconds.</li> <li>5 Services, each one pointing to the TCP/8080 port of one of the nginx Deployments.</li> <li>2 edge Routes pointing to the to first and second Services respectively</li> <li>10 Secrets containing 2048 character random string</li> <li>10 ConfigMaps containing a 2048 character random string</li> <li>3 NetworkPolicies:<ol> <li>1 deny-all traffic</li> <li>1 allow traffic from client/nginx pods to server/nginx pods</li> <li>1 allow traffic from openshift-ingress namespace (where routers are deployed by default) to the namespace</li> </ol> </li> </ul>"},{"location":"ocp/#cluster-density-ms","title":"cluster-density-ms","text":"<p>Lightest version of this workload family, each iteration the following objects in each of the created namespaces:</p> <ul> <li>1 ImageStream</li> <li>4 Deployments with two pod replicas (pause) mounting 4 secrets, 4 configmaps and 1 downwardAPI volume each</li> <li>2 Services, each one pointing to the TCP/8080 and TCP/8443 ports of the first and second deployment respectively.</li> <li>1 edge Route pointing to the to first service</li> <li>20 Secrets containing 2048 character random string</li> <li>10 ConfigMaps containing a 2048 character random string</li> </ul>"},{"location":"ocp/#node-density-workloads","title":"Node density workloads","text":"<p>The workloads of this family create a single namespace with a set of Pods, Deployments Services, depending on the workload.</p>"},{"location":"ocp/#node-density","title":"node-density","text":"<p>This workload is meant to fill with pause pods all the worker nodes from the cluster. It can be customized with the following flags. This workload is usually used to measure the Pod's ready latency KPI.</p>"},{"location":"ocp/#node-density-cni","title":"node-density-cni","text":"<p>It creates two Deployments, a client/curl and a server/nxing, and 1 Service backed by the previous server Pods. The client application has configured an startupProbe that makes requests to the previous Service every second with a timeout of 600s.</p>"},{"location":"ocp/#node-density-heavy","title":"node-density-heavy","text":"<p>Creates two Deployments, a postgresql database and a simple client that performs periodic insert queries (configured through liveness and readiness probes) on the previous database and a Service that is used by the client to reach the database.</p>"},{"location":"ocp/#customizing-workloads","title":"Customizing workloads","text":"<p>It's possible to customize any of the above workload configurations by extracting, updating and finally running it:</p> <pre><code>$ kube-burner ocp node-density --extract\n$ ls\nalerts.yml  metrics.yml  node-density.yml  pod.yml\n$ vi node-density.yml                               # Perform modifications accordingly\n$ kube-burner ocp node-density --pods-per-node=100  # Run workload\n</code></pre>"},{"location":"ocp/#cluster-metadata","title":"Cluster metadata","text":"<p>When benchmark finishes, kube-burner will index the cluster metadata in the configured indexer. At the time of writing this document is based on the following golang struct:</p> <pre><code>type clusterMetadata struct {\nMetricName       string                 `json:\"metricName,omitempty\"`\nUUID             string                 `json:\"uuid\"`\nPlatform         string                 `json:\"platform\"`\nOCPVersion       string                 `json:\"ocpVersion\"`\nK8SVersion       string                 `json:\"k8sVersion\"`\nMasterNodesType  string                 `json:\"masterNodesType\"`\nWorkerNodesType  string                 `json:\"workerNodesType\"`\nInfraNodesType   string                 `json:\"infraNodesType\"`\nWorkerNodesCount int                    `json:\"workerNodesCount\"`\nInfraNodesCount  int                    `json:\"infraNodesCount\"`\nTotalNodes       int                    `json:\"totalNodes\"`\nSDNType          string                 `json:\"sdnType\"`\nBenchmark        string                 `json:\"benchmark\"`\nTimestamp        time.Time              `json:\"timestamp\"`\nEndDate          time.Time              `json:\"endDate\"`\nClusterName      string                 `json:\"clusterName\"`\nPassed           bool                   `json:\"passed\"`\nMetadata         map[string]interface{} `json:\"metadata,omitempty\"`\n}\n</code></pre> <p>Where metricName is hardcoded to <code>clusterMetadata</code></p>"},{"location":"development/","title":"Contributing to kube-burner","text":"<p>If you want to contribute to kube-burner, submit a Pull Request, Issue or start a Discussion.</p>"},{"location":"development/#building","title":"Building","text":"<p>To build kube-burner just execute <code>make build</code>, once finished the kube-burner binary should be available at <code>./bin/&lt;arch&gt;/kube-burner</code>.</p> <p>Note</p> <p>Building kube-burner requires <code>golang &gt;=1.19</code></p> <pre><code>$ make build\nbuilding kube-burner 0.1.0\nGOPATH=/home/kube-burner/go\nCGO_ENABLED=0 go build -v -ldflags \"-X github.com/cloud-bulldozer/kube-burner/version.GitCommit=d91c8cc35cb458a4b80a5050704a51c7c6e35076 -X github.com/cloud-bulldozer/kube-burner/version.BuildDate=2020-08-19-19:10:09 -X github.com/cloud-bulldozer/kube-burner/version.GitBranch=master\" -o bin/kube-burner\n</code></pre>"},{"location":"development/ci/","title":"Continuous Integration Documentation","text":"<p>This documentation provides an overview of the different jobs and their execution in the CI workflow. The CI workflow consists of several jobs that automate various tasks such as building binaries and images, executing tests, generating and deploying documentation, creating releases, and uploading containers. Each job is triggered based on specific events.</p>"},{"location":"development/ci/#pull-request-workflow","title":"Pull Request workflow","text":"<p>The pull Request Workflow, defined in the <code>pullrequest.yml</code> file, is triggered on <code>pull_request_target</code> events to the branches <code>master</code> and <code>main</code>. It has three jobs: linters, build, tests, and report_results.</p> <pre><code>graph LR\n  A[pull_request_target] --&gt; B[linters];\n  B --&gt; C[build];\n  C --&gt; D[tests];\n  C --&gt; D[report_results];</code></pre>"},{"location":"development/ci/#linters","title":"Linters","text":"<p>This job performs the following steps:</p> <ol> <li>Checks out the code</li> <li>Installs pre-commit.</li> <li>Runs pre-commit hooks to execute code linting based on <code>.pre-commit-config.yaml</code> file</li> </ol>"},{"location":"development/ci/#running-local-pre-commit","title":"Running local pre-commit","text":"<p>Info</p> <p>Main purpose for pre-commit is to allow developers to pass the Lint Checks before commiting the code. Same checks will be executed on all the commits once they are pushed to GitHub</p> <p>To install pre-commit checks locally, follow these steps:</p> <ol> <li> <p>Install pre-commit by running the following command:</p> <pre><code>pip install pre-commit\n</code></pre> </li> <li> <p><code>ruby</code> is required for running the Markdown Linter, installation will depends on your Operating System, for example, on Fedora:</p> <pre><code>dnf install -y ruby\n</code></pre> </li> <li> <p>Initialize pre-commit on the repo:</p> <pre><code>pre-commit install\n</code></pre> </li> </ol> <p>To run pre-commit manually for all files, you can use <code>make lint</code></p> <pre><code>make lint\n</code></pre> <p>Or you can run against an especific file:</p> <pre><code>$ pre-commit run --files README.md\ngolangci-lint........................................(no files to check)Skipped\nMarkdownlint.............................................................Passed\n</code></pre> <pre><code>$ pre-commit run --files ./cmd/kube-burner/kube-burner.go\ngolangci-lint............................................................Passed\nMarkdownlint.........................................(no files to check)Skipped\n</code></pre> <pre><code>$ pre-commit run --all-files\ngolangci-lint............................................................Passed\nMarkdownlint.............................................................Passed\n</code></pre> <p>Pre-commit hooks can be updated using <code>pre-commit autoupdate</code>:</p> <pre><code>$ pre-commit autoupdate\n[WARNING] The 'rev' field of repo 'https://github.com/golangci/golangci-lint' appears to be a mutable reference (moving tag / branch).  Mutable references are never updated after first install and are not supported.  See https://pre-commit.com/#using-the-latest-version-for-a-repository for more details.  Hint: `pre-commit autoupdate` often fixes this.\n[WARNING] The 'rev' field of repo 'https://github.com/markdownlint/markdownlint' appears to be a mutable reference (moving tag / branch).  Mutable references are never updated after first install and are not supported.  See https://pre-commit.com/#using-the-latest-version-for-a-repository for more details.  Hint: `pre-commit autoupdate` often fixes this.\n[WARNING] The 'rev' field of repo 'https://github.com/jumanjihouse/pre-commit-hooks' appears to be a mutable reference (moving tag / branch).  Mutable references are never updated after first install and are not supported.  See https://pre-commit.com/#using-the-latest-version-for-a-repository for more details.  Hint: `pre-commit autoupdate` often fixes this.\n[https://github.com/golangci/golangci-lint] updating master -&gt; v1.52.2\n[https://github.com/markdownlint/markdownlint] updating master -&gt; v0.12.0\n[https://github.com/jumanjihouse/pre-commit-hooks] updating master -&gt; 3.0.0\n</code></pre>"},{"location":"development/ci/#build","title":"Build","text":"<p>The \"build\" job uses the file <code>builders.yml</code> file to build binaries and images, performing the following steps:</p> <ol> <li>Sets up Go 1.19.</li> <li>Checks out the code.</li> <li>Builds the code using the <code>make build</code> command.</li> <li>Builds container images using the <code>make images</code> command</li> <li>Installs the built artifacts using <code>sudo make install</code> command.</li> <li>Uploads the built binary file as an artifact named kube-burner.</li> </ol>"},{"location":"development/ci/#tests","title":"Tests","text":"<p>The Tests Workflow, defined in the <code>tests-k8s.yml</code> file, has two jobs: test-k8s and ocp-wrapper.</p> <p>Tests are orchestrated using BATS</p>"},{"location":"development/ci/#test-k8s","title":"Test K8s","text":"<p>For testing kube-burner on a real k8s environment, we use Kind, with different K8s versions.</p> <p>It creates a quick k8s deployment using containers with podman.</p> <p>The test-k8s job performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Downloads the kube-burner binary artifact.</li> <li>Installs Bats and the oc command-line tool.</li> <li>Executes tests using Bats and generates a JUnit report.</li> <li>Uploads the test results artifact.</li> <li>Publishes the test report using the mikepenz/action-junit-report action.</li> </ol>"},{"location":"development/ci/#test-ocp","title":"Test OCP","text":"<p>For testing OCP, we use a real OCP</p> <p>The ocp-wrapper job performs similar steps to the \"test-k8s\" job but with additional OpenShift-specific configurations and secrets.</p>"},{"location":"development/ci/#kube-burner-tests-executed","title":"Kube-burner tests executed","text":"<p>The kube-burner tests executed on each environment can be found on following files included in the folder <code>/test/</code></p> <ul> <li>K8s: <code>test/test-k8s.bats</code></li> <li>OCP: <code>test/test-ocp.bats</code></li> </ul>"},{"location":"development/ci/#report-results","title":"Report Results","text":"<p>The \"report_results\" job performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Downloads the Kubernetes and OpenShift test results artifacts.</li> <li>Publishes the test results and add a comment in the PR</li> </ol>"},{"location":"development/ci/#release-workflow","title":"Release workflow","text":"<p>The Release workflow, defined in the <code>release.yml</code> file, when a new tag is pushed it triggers: release-build and image-upload.</p> <pre><code>graph LR\n  A[new tag pushed] --&gt; B[release_build];\n  A --&gt; C[image-upload];\n  B --&gt; D[docs-update];</code></pre> <p>The <code>docs-update</code> job is triggered when a new release is <code>published</code>, this is done by the <code>release_build</code> job.</p>"},{"location":"development/ci/#release-build","title":"Release Build","text":"<p>This job uses the GoRelease workflow defined in the <code>gorelease.yml</code> file to create a new release of the project performing the following steps:</p> <ol> <li>Checks out the code into the Go module directory.</li> <li>Sets up Go 1.19.</li> <li>Runs GoReleaser to create a new release, including the removal of previous distribution files.</li> </ol>"},{"location":"development/ci/#image-upload","title":"Image Upload","text":"<p>This job uses the Upload Containers to Quay workflow defined in the <code>image-upload.yml</code> file to upload containers to the Quay registry for multiple architectures (arm64, amd64, ppc64le, s390x) performing the following steps:</p> <ol> <li>Installs the dependencies required for multi-architecture builds.</li> <li>Checks out the code.</li> <li>Sets up Go 1.19.</li> <li>Logs in to Quay using the provided QUAY_USER and QUAY_TOKEN secrets.</li> <li>Builds the kube-burner binary for the specified architecture.</li> <li>Builds the container image using the make images command, with environment variables for architecture and organization.</li> <li>Pushes the container image to Quay using the make push command.</li> </ol> <p>The \"manifest\" job builds a container manifest and runs after the \"containers\" job. It performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Logs in to Quay using the provided QUAY_USER and QUAY_TOKEN secrets.</li> <li>Creates and pushes the container manifest using the make manifest command, with the organization specified.</li> </ol>"},{"location":"development/ci/#docs-update","title":"Docs Update","text":"<p>Uses the <code>Deploy docs</code> workflow defined in the <code>docs.yml</code> file to generate and deploy the documentation performing the following steps:</p> <ol> <li>Checks out the code.</li> <li>Sets up Python 3.x.</li> <li>Exports the release tag version as an environment variable.</li> <li>Sets up the Git configuration for documentation deployment.</li> <li>Installs the required dependencies, including mkdocs-material and mike.</li> <li>Deploys the documentation using the mike deploy command, with specific parameters for updating aliases and including the release tag version in the deployment message.</li> </ol>"},{"location":"development/ci/pullrequest/","title":"Pullrequest","text":"<p>The pull Request Workflow, defined in the <code>pullrequest.yml</code> file, is triggered on <code>pull_request_target</code> events to the branches <code>master</code> and <code>main</code>. It has three jobs: linters, build, tests, and report_results.</p> <pre><code>graph LR\n  A[pull_request_target] --&gt; B[linters];\n  B --&gt; C[build];\n  C --&gt; D[tests];\n  C --&gt; D[report_results];</code></pre>"},{"location":"development/ci/pullrequest/#linters","title":"Linters","text":"<p>This job performs the following steps:</p> <ol> <li>Checks out the code</li> <li>Installs pre-commit.</li> <li>Runs pre-commit hooks to execute code linting based on <code>.pre-commit-config.yaml</code> file</li> </ol>"},{"location":"development/ci/pullrequest/#running-local-pre-commit","title":"Running local pre-commit","text":"<p>Info</p> <p>Main purpose for pre-commit is to allow developers to pass the Lint Checks before commiting the code. Same checks will be executed on all the commits once they are pushed to GitHub</p> <p>To install pre-commit checks locally, follow these steps:</p> <ol> <li> <p>Install pre-commit by running the following command:</p> <pre><code>pip install pre-commit\n</code></pre> </li> <li> <p><code>ruby</code> is required for running the Markdown Linter, installation will depends on your Operating System, for example, on Fedora:</p> <pre><code>dnf install -y ruby\n</code></pre> </li> <li> <p>Initialize pre-commit on the repo:</p> <pre><code>pre-commit install\n</code></pre> </li> </ol> <p>To run pre-commit manually for all files, you can use <code>make lint</code></p> <pre><code>make lint\n</code></pre> <p>Or you can run against an especific file:</p> <pre><code>$ pre-commit run --files README.md\ngolangci-lint........................................(no files to check)Skipped\nMarkdownlint.............................................................Passed\n</code></pre> <pre><code>$ pre-commit run --files ./cmd/kube-burner/kube-burner.go\ngolangci-lint............................................................Passed\nMarkdownlint.........................................(no files to check)Skipped\n</code></pre> <pre><code>$ pre-commit run --all-files\ngolangci-lint............................................................Passed\nMarkdownlint.............................................................Passed\n</code></pre> <p>Pre-commit hooks can be updated using <code>pre-commit autoupdate</code>:</p> <pre><code>$ pre-commit autoupdate\n[WARNING] The 'rev' field of repo 'https://github.com/golangci/golangci-lint' appears to be a mutable reference (moving tag / branch).  Mutable references are never updated after first install and are not supported.  See https://pre-commit.com/#using-the-latest-version-for-a-repository for more details.  Hint: `pre-commit autoupdate` often fixes this.\n[WARNING] The 'rev' field of repo 'https://github.com/markdownlint/markdownlint' appears to be a mutable reference (moving tag / branch).  Mutable references are never updated after first install and are not supported.  See https://pre-commit.com/#using-the-latest-version-for-a-repository for more details.  Hint: `pre-commit autoupdate` often fixes this.\n[WARNING] The 'rev' field of repo 'https://github.com/jumanjihouse/pre-commit-hooks' appears to be a mutable reference (moving tag / branch).  Mutable references are never updated after first install and are not supported.  See https://pre-commit.com/#using-the-latest-version-for-a-repository for more details.  Hint: `pre-commit autoupdate` often fixes this.\n[https://github.com/golangci/golangci-lint] updating master -&gt; v1.52.2\n[https://github.com/markdownlint/markdownlint] updating master -&gt; v0.12.0\n[https://github.com/jumanjihouse/pre-commit-hooks] updating master -&gt; 3.0.0\n</code></pre>"},{"location":"development/ci/pullrequest/#build","title":"Build","text":"<p>The \"build\" job uses the file <code>builders.yml</code> file to build binaries and images, performing the following steps:</p> <ol> <li>Sets up Go 1.19.</li> <li>Checks out the code.</li> <li>Builds the code using the <code>make build</code> command.</li> <li>Builds container images using the <code>make images</code> command</li> <li>Installs the built artifacts using <code>sudo make install</code> command.</li> <li>Uploads the built binary file as an artifact named kube-burner.</li> </ol>"},{"location":"development/ci/pullrequest/#tests","title":"Tests","text":"<p>The Tests Workflow, defined in the <code>tests-k8s.yml</code> file, has two jobs: test-k8s and ocp-wrapper.</p> <p>Tests are orchestrated using BATS</p>"},{"location":"development/ci/pullrequest/#test-k8s","title":"Test K8s","text":"<p>For testing kube-burner on a real k8s environment, we use Kind, with different K8s versions.</p> <p>It creates a quick k8s deployment using containers with podman.</p> <p>The test-k8s job performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Downloads the kube-burner binary artifact.</li> <li>Installs Bats and the oc command-line tool.</li> <li>Executes tests using Bats and generates a JUnit report.</li> <li>Uploads the test results artifact.</li> <li>Publishes the test report using the mikepenz/action-junit-report action.</li> </ol>"},{"location":"development/ci/pullrequest/#test-ocp","title":"Test OCP","text":"<p>For testing OCP, we use a real OCP</p> <p>The ocp-wrapper job performs similar steps to the \"test-k8s\" job but with additional OpenShift-specific configurations and secrets.</p>"},{"location":"development/ci/pullrequest/#kube-burner-tests-executed","title":"Kube-burner tests executed","text":"<p>The kube-burner tests executed on each environment can be found on following files included in the folder <code>/test/</code></p> <ul> <li>K8s: <code>test/test-k8s.bats</code></li> <li>OCP: <code>test/test-ocp.bats</code></li> </ul>"},{"location":"development/ci/pullrequest/#report-results","title":"Report Results","text":"<p>The \"report_results\" job performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Downloads the Kubernetes and OpenShift test results artifacts.</li> <li>Publishes the test results and add a comment in the PR</li> </ol>"},{"location":"development/ci/release/","title":"Release","text":"<p>The Release workflow, defined in the <code>release.yml</code> file, when a new tag is pushed it triggers: release-build and image-upload.</p> <pre><code>graph LR\n  A[new tag pushed] --&gt; B[release_build];\n  A --&gt; C[image-upload];\n  B --&gt; D[docs-update];</code></pre> <p>The <code>docs-update</code> job is triggered when a new release is <code>published</code>, this is done by the <code>release_build</code> job.</p>"},{"location":"development/ci/release/#release-build","title":"Release Build","text":"<p>This job uses the GoRelease workflow defined in the <code>gorelease.yml</code> file to create a new release of the project performing the following steps:</p> <ol> <li>Checks out the code into the Go module directory.</li> <li>Sets up Go 1.19.</li> <li>Runs GoReleaser to create a new release, including the removal of previous distribution files.</li> </ol>"},{"location":"development/ci/release/#image-upload","title":"Image Upload","text":"<p>This job uses the Upload Containers to Quay workflow defined in the <code>image-upload.yml</code> file to upload containers to the Quay registry for multiple architectures (arm64, amd64, ppc64le, s390x) performing the following steps:</p> <ol> <li>Installs the dependencies required for multi-architecture builds.</li> <li>Checks out the code.</li> <li>Sets up Go 1.19.</li> <li>Logs in to Quay using the provided QUAY_USER and QUAY_TOKEN secrets.</li> <li>Builds the kube-burner binary for the specified architecture.</li> <li>Builds the container image using the make images command, with environment variables for architecture and organization.</li> <li>Pushes the container image to Quay using the make push command.</li> </ol> <p>The \"manifest\" job builds a container manifest and runs after the \"containers\" job. It performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Logs in to Quay using the provided QUAY_USER and QUAY_TOKEN secrets.</li> <li>Creates and pushes the container manifest using the make manifest command, with the organization specified.</li> </ol>"},{"location":"development/ci/release/#docs-update","title":"Docs Update","text":"<p>Uses the <code>Deploy docs</code> workflow defined in the <code>docs.yml</code> file to generate and deploy the documentation performing the following steps:</p> <ol> <li>Checks out the code.</li> <li>Sets up Python 3.x.</li> <li>Exports the release tag version as an environment variable.</li> <li>Sets up the Git configuration for documentation deployment.</li> <li>Installs the required dependencies, including mkdocs-material and mike.</li> <li>Deploys the documentation using the mike deploy command, with specific parameters for updating aliases and including the release tag version in the deployment message.</li> </ol>"},{"location":"development/ci/tests/","title":"Tests","text":"<p>The Tests Workflow, defined in the <code>tests-k8s.yml</code> file, has two jobs: test-k8s and ocp-wrapper.</p> <p>Tests are orchestrated using BATS</p>"},{"location":"development/ci/tests/#test-k8s","title":"Test K8s","text":"<p>For testing kube-burner on a real k8s environment, we use Kind, with different K8s versions.</p> <p>It creates a quick k8s deployment using containers with podman.</p> <p>The test-k8s job performs the following steps:</p> <ol> <li>Checks out the code.</li> <li>Downloads the kube-burner binary artifact.</li> <li>Installs Bats and the oc command-line tool.</li> <li>Executes tests using Bats and generates a JUnit report.</li> <li>Uploads the test results artifact.</li> <li>Publishes the test report using the mikepenz/action-junit-report action.</li> </ol>"},{"location":"development/ci/tests/#test-ocp","title":"Test OCP","text":"<p>For testing OCP, we use a real OCP</p> <p>The ocp-wrapper job performs similar steps to the \"test-k8s\" job but with additional OpenShift-specific configurations and secrets.</p>"},{"location":"development/ci/tests/#kube-burner-tests-executed","title":"Kube-burner tests executed","text":"<p>The kube-burner tests executed on each environment can be found on following files included in the folder <code>/test/</code></p> <ul> <li>K8s: <code>test/test-k8s.bats</code></li> <li>OCP: <code>test/test-ocp.bats</code></li> </ul>"},{"location":"observability/","title":"Overview","text":"<p>Performing a benchmark using a kube-burner is relatively simple, however sometimes it's necessary to analyze and be able to react to some KPIs in order to validate a benchmark. That's the reason why kube-burner ships a metric-collection and alerting systems based on Prometheus expressions.</p> <p>Kube-burner also ships an indexing feature that, in combination with the metric-collection and alerting features, can be used to analyze these KPIs in an external tool, such as Grafana or similars.</p> <p>With this we can describe the benchmark stages with the following diagram:</p> <pre><code>flowchart TD\n    A[/\"Init benchmark\"/] -- Read config --&gt; B(Start measurements)\n    B --&gt; C(Run Job)\n    C --&gt; D{Next job?}\n    D --&gt; |Yes| C\n    D --&gt; |No| E[Stop measurements]\n    E --&gt; F[Evaluate alerts]\n    F --&gt; G[(Index results)]\n    G --&gt; H[Indexing]\n    H --&gt; I*[/End/]</code></pre>"},{"location":"observability/alerting/","title":"Alerting","text":"<p>Kube-burner includes an alerting feature able to evaluate Prometheus expressions in order to fire and index alerts.</p>"},{"location":"observability/alerting/#configuration","title":"Configuration","text":"<p>Alerting is configured through a configuration file pointed by the flag <code>--alert-profile</code> or <code>-a</code>, which is a YAML formatted file with the following shape:</p> <pre><code>- expr: avg_over_time(histogram_quantile(0.99, rate(etcd_disk_wal_fsync_duration_seconds_bucket[2m]))[5m:]) &gt; 0.01\ndescription: 5 minutes avg. etcd fsync latency on {{$labels.pod}} higher than 10ms {{$value}}\nseverity: error\n\n- expr: avg_over_time(histogram_quantile(0.99, rate(etcd_network_peer_round_trip_time_seconds_bucket[5m]))[5m:]) &gt; 0.1\ndescription: 5 minutes avg. etcd netowrk peer round trip on {{$labels.pod}} higher than 100ms {{$value}}\nseverity: error\n\n- expr: increase(etcd_server_leader_changes_seen_total[2m]) &gt; 0\ndescription: etcd leader changes observed\nseverity: error\n</code></pre> <p>Where <code>expr</code> holds the PromQL to evaluate and <code>description</code> holds a description of the alert, that will be printed/indexed when the alert fires. In <code>description</code> we can make use of prometheus labels to increase alert readabiliy by using the syntax <code>{{$labels.&lt;label_name&gt;}}</code> and also print value of the value that fired the alarm using <code>{{$value}}</code>.</p> <p>Alerts can be configured with a severity. Each one has different effects. These are:</p> <ul> <li><code>info</code>: Prints an info message with the alarm description to stdout. By default all expressions have this severity.</li> <li><code>warning</code>: Prints a warning message with the alarm description to stdout.</li> <li><code>error</code>: Prints an error message with the alarm description to stdout and makes kube-burner rc = 1</li> <li><code>critical</code>: Prints a fatal message with the alarm description to stdout and aborts execution immediately with rc =1 0</li> </ul>"},{"location":"observability/alerting/#using-the-elapsed-variable","title":"Using the elapsed variable","text":"<p>There's a special go-template variable that can be used within the prometheus expression, the variable elapsed is set to the value of the job duration (or the range given to check-alerts). This variable is especially useful in expressions using aggregations over time functions. i.e:</p> <pre><code>- expr: avg_over_time(histogram_quantile(0.99, rate(etcd_disk_wal_fsync_duration_seconds_bucket[2m]))[{{ .elapsed }}:]) &gt; 0.01\ndescription: avg. etcd fsync latency on {{$labels.pod}} higher than 10ms {{$value}}\nseverity: error\n</code></pre>"},{"location":"observability/alerting/#checking-alerts","title":"Checking alerts","text":"<p>It's possible to look for alerts w/o triggering a kube-burner workload by using the <code>check-alerts</code> subcommand. Similar to the <code>index</code> CLI option, this one accepts the flags <code>--start</code> and <code>--end</code> to evaluate the alerts at a given time range.</p> <pre><code>$ kube-burner check-alerts -u https://prometheus.url.com -t ${token} -a alert-profile.yml\nINFO[2020-12-10 11:47:23] \ud83d\udc7d Initializing prometheus client\nINFO[2020-12-10 11:47:24] \ud83d\udd14 Initializing alert manager\nINFO[2020-12-10 11:47:24] Evaluating expression: 'avg_over_time(histogram_quantile(0.99, rate(etcd_disk_wal_fsync_duration_seconds_bucket[2m]))[5m:]) &gt; 0.01'\nERRO[2020-12-10 11:47:24] Alert triggered at 2020-12-10 11:01:53 +0100 CET: '5 minutes avg. etcd fsync latency on etcd-ip-10-0-213-209.us-west-2.compute.internal higher than 10ms 0.010281314285714311'\nINFO[2020-12-10 11:47:24] Evaluating expression: 'avg_over_time(histogram_quantile(0.99, rate(etcd_network_peer_round_trip_time_seconds_bucket[5m]))[5m:]) &gt; 0.1'\nINFO[2020-12-10 11:47:24] Evaluating expression: 'increase(etcd_server_leader_changes_seen_total[2m]) &gt; 0'\nINFO[2020-12-10 11:47:24] Evaluating expression: 'avg_over_time(histogram_quantile(0.99, sum(apiserver_request_duration_seconds_bucket{apiserver=\"kube-apiserver\",verb=~\"POST|PUT|DELETE|PATCH|CREATE\"}) by (verb,resource,subresource,le))[5m\n:]) &gt; 1'\nINFO[2020-12-10 11:47:25] Evaluating expression: 'avg_over_time(histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{apiserver=\"kube-apiserver\",verb=\"GET\",scope=\"resource\"}[2m])) by (verb,resource,subresource,le))[5\nm:]) &gt; 1'\nINFO[2020-12-10 11:47:25] Evaluating expression: 'avg_over_time(histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{apiserver=\"kube-apiserver\",verb=\"LIST\",scope=\"namespace\"}[2m])) by (verb,resource,subresource,le))\n[5m:]) &gt; 5'\nINFO[2020-12-10 11:47:26] Evaluating expression: 'avg_over_time(histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{apiserver=\"kube-apiserver\",verb=\"LIST\",scope=\"cluster\"}[2m])) by (verb,resource,subresource,le))[5\nm:]) &gt; 30'\n</code></pre>"},{"location":"observability/alerting/#indexing-alerts","title":"Indexing alerts","text":"<p>When indexing is enabled, the alerts fired by kube-burner are automatically indexed by the provided <code>indexer</code>. The documents generated by these alerts have the following structure:</p> <pre><code>{\n\"timestamp\": \"2023-01-19T22:20:10+01:00\",\n\"uuid\": \"c0dd0d60-ddf5-488e-bf2f-b8960fc2b5ab\",\n\"severity\": \"warning\",\n\"description\": \"5 minutes avg. 99th etcd fsync latency on etcd-ip-10-0-133-30.us-west-2.compute.internal higher than 10ms. 0.004s\",\n\"metricName\": \"alert\"\n}\n</code></pre>"},{"location":"observability/indexing/","title":"Indexing","text":"<p>Kube-burner can index the collected metrics metrics into a given indexer.</p>"},{"location":"observability/indexing/#indexers","title":"Indexers","text":"<p>Configured in the <code>indexerConfig</code> object, they can be tweaked by the following parameters:</p> Option Description Type Default <code>enabled</code> Enable indexing Boolean false <code>type</code> Type of indexer String \"\" <p>Note</p> <p>At the moment <code>elastic</code> and <code>local</code> are the only supported indexers</p>"},{"location":"observability/indexing/#elastic","title":"Elastic","text":"<p>This indexer send collected documents to Elasticsearch 7 instances.</p> <p>The <code>elastic</code> indexer can be configured by the parameters below:</p> Option Description Type Default <code>esServers</code> List of ES instances List \"\" <code>defaultIndex</code> Default index to send the prometheus metrics into String \"\" <code>insecureSkipVerify</code> TLS certificate verification Boolean false <p>Info</p> <p>It's possible to index documents in an authenticated ES instance using the notation <code>http(s)://[username]:[password]@[address]:[port]</code> in the <code>esServers</code> parameter.</p>"},{"location":"observability/indexing/#local","title":"Local","text":"<p>This indexer writes collected metrics to local files.</p> <p>The <code>local</code> indexer can be configured by the parameters below:</p> Option Description Type Default <code>metricsDirectory</code> Collected metric will be dumped here. String collected-metrics <code>createTarball</code> Create metrics tarball Boolean false <code>tarballName</code> Name of the metrics tarball String kube-burner-metrics.tgz"},{"location":"observability/indexing/#job-summary","title":"Job Summary","text":"<p>When an indexer is configued, at the end of each job, a document holding the job summary is indexed. This is useful to identify the parameters the job was executed with:</p> <p>This document looks like:</p> <pre><code>{\n\"timestamp\": \"2020-11-13T13:55:31.654185032+01:00\",\n\"uuid\": \"bdb7584a-d2cd-4185-8bfa-1387cc31f99e\",\n\"metricName\": \"jobSummary\",\n\"elapsedTime\": 8.768932955,\n\"jobConfig\": {\n\"jobIterations\": 10,\n\"jobIterationDelay\": 0,\n\"jobPause\": 0,\n\"name\": \"kubelet-density\",\n\"objects\": [\n{\n\"objectTemplate\": \"templates/pod.yml\",\n\"replicas\": 1,\n\"inputVars\": {\n\"containerImage\": \"gcr.io/google_containers/pause-amd64:3.0\"\n}\n}\n],\n\"jobType\": \"create\",\n\"qps\": 5,\n\"burst\": 5,\n\"namespace\": \"kubelet-density\",\n\"waitFor\": null,\n\"maxWaitTimeout\": 43200000000000,\n\"waitForDeletion\": true,\n\"podWait\": false,\n\"waitWhenFinished\": true,\n\"cleanup\": true,\n\"namespacedIterations\": false,\n\"verifyObjects\": true,\n\"errorOnVerify\": false\n}\n}\n</code></pre>"},{"location":"observability/indexing/#metric-exporting-importing","title":"Metric exporting &amp; importing","text":"<p>When using the <code>local</code> indexer, it's possible to dump all the collected metrics to a tarball, so we import them later, this is useful in disconnected environments, where kube-burner doesn't have direct access to a ElasticSearch instance. Metrics exporting can be configured by <code>createTarball</code> field of the indexer config as noted in the local indexer.</p> <p>The metric exporting feature is available in by using the <code>init</code> and <code>index</code> subcommands.</p> <p>Once we've enabled it, a tarball (<code>kube-burner-metrics-&lt;timestamp&gt;.tgz</code>) containing all metrics will be generated in the current working directory. This tarball can be imported and indexed by kube-burner with the <code>import</code> subcommand. For example:</p> <pre><code>$ kube-burner/bin/kube-burner import --config kubelet-config.yml --tarball kube-burner-metrics-1624441857.tgz\nINFO[2021-06-23 11:39:40] \ud83d\udcc1 Creating indexer: elastic\nINFO[2021-06-23 11:39:42] Importing tarball kube-burner-metrics-1624441857.tgz\nINFO[2021-06-23 11:39:42] Importing metrics from doc.json\nINFO[2021-06-23 11:39:43] Indexing [1] documents in kube-burner\nINFO[2021-06-23 11:39:43] Successfully indexed [1] documents in 208ms in kube-burner\n</code></pre>"},{"location":"observability/indexing/#scraping-from-multiple-endpoints","title":"Scraping from multiple endpoints","text":"<p>It's possible to scrape from multiple prometheus endpoints and send the results to the target indexer with the <code>init</code> and <code>index</code> subcommands. This feature is configured by the flag <code>--metrics-endpoint</code>, which points to a YAML file with the required configuration.</p> <p>A valid file provided to the <code>--metrics-endpoint</code> would look like this.</p> <pre><code>- endpoint: http://localhost:9090  # This is one of the Prometheus endpoints\ntoken: &lt;token&gt;                   # Authentication token\nprofile: metrics.yaml            # Metrics profile to use in this target\nalertProfile: alerts.yaml        # Alert profile, optional\n- endpoint: http://remotehost:9090 # Another Prometheus endpoint\ntoken: &lt;token&gt;\nprofile: metrics.yaml\n</code></pre> <p>Note</p> <p>The configuration provided by the <code>--metrics-endpoint</code> flag has precedence over the parameters specified in the config file. The <code>profile</code> and <code>alertProfile</code> parameters are optional. If not provided they will be taken from the CLI flags.</p>"},{"location":"observability/metrics/","title":"Metric profile","text":"<p>The metric-collection feature is configured through a file pointed by the <code>metrics-profile</code> flag. Which can point to a local path or URL of a YAML formatted file containing a list of the prometheus expressions. Kube-burner will perform those queries one by one once all benchmark's jobs are done and transform them into a JSON formatted list.</p> <p>In a single job benchmark, the queries are executed using the benchmark start and end time as time range. In multiple job benchmarks these queries are executed in a per job basis, and they take the different start, end time from the executed jobs.</p> <p>The metrics profile file has the following structure:</p> <pre><code>- query: irate(process_cpu_seconds_total{job=~\".*(crio|etcd|controller-manager|apiserver|scheduler).*\"}[2m])\nmetricName: controlPlaneCPU\n\n- query: sum(irate(node_cpu_seconds_total[2m])) by (mode,instance)\nmetricName: nodeCPU\n</code></pre> <p>Where <code>query</code> holds the prometheus expression to evaluate, and <code>metricName</code> controls the value that kube-burner will set on the <code>metricName</code> field, useful to identify metrics from a specific query. More info in the metric format section</p> <p>In addition to range queries, kube-burner has the ability perform instant queries by adding the field <code>instant</code> to the desired metric. This kind of query is especially useful to get only one sample of a static metric such as a component version or the number of nodes of the cluster.</p> <pre><code>- query: kube_node_role\nmetricName: nodeRoles\ninstant: true\n</code></pre>"},{"location":"observability/metrics/#metric-format","title":"Metric format","text":"<p>The collected metrics have the following shape:</p> <pre><code>[\n{\n\"timestamp\": \"2021-06-23T11:50:15+02:00\",\n\"labels\": {\n\"instance\": \"ip-10-0-219-170.eu-west-3.compute.internal\",\n\"mode\": \"user\"\n},\n\"value\": 0.3300880234732172,\n\"uuid\": \"bc82badf-0e43-48cc-aca8-fdaa6cee5a84\",\n\"query\": \"sum(irate(node_cpu_seconds_total[2m])) by (mode,instance) &gt; 0\",\n\"metricName\": \"nodeCPU\",\n\"jobName\": \"kube-burner-indexing\"\n},\n{\n\"timestamp\": \"2021-06-23T11:50:45+02:00\",\n\"labels\": {\n\"instance\": \"ip-10-0-219-170.eu-west-3.compute.internal\",\n\"mode\": \"user\"\n},\n\"value\": 0.31978102677038506,\n\"uuid\": \"bc82badf-0e43-48cc-aca8-fdaa6cee5a84\",\n\"query\": \"sum(irate(node_cpu_seconds_total[2m])) by (mode,instance) &gt; 0\",\n\"metricName\": \"nodeCPU\",\n\"jobName\": \"kube-burner-indexing\"\n}\n]\n</code></pre> <p>Notice that kube-burner enriches the query results by adding some extra fields like <code>uuid</code>, <code>query</code>, <code>metricName</code> and <code>jobName</code>.</p> <p>Info</p> <p>These extra fields are specially useful at the time of identifying and representing the collected metrics.</p>"},{"location":"observability/metrics/#using-the-elapsed-variable","title":"Using the elapsed variable","text":"<p>There's a special go-template variable that can be used within the prometheus expressions of a metric profile, the variable <code>elapsed</code> is automatically populeted with the job duration duration, in minutes. This variable is specially useful in PromQL expressions using aggregations over time functions.</p> <p>For example, the following expression gets the top 3 CPU usage kubelets processes across the cluster.</p> <pre><code>- query: irate(process_cpu_seconds_total{service=\"kubelet\",job=\"kubelet\"}[2m]) * 100 and on (node) topk(3,avg_over_time(irate(process_cpu_seconds_total{service=\"kubelet\",job=\"kubelet\"}[2m])[{{ .elapsed }}:]))\nmetricName: top3KubeletCPU\n</code></pre> <p>Examples of metrics profiles can be found in the examples directory. There're are also ElasticSearch based grafana dashboards available in the same examples directory.</p>"},{"location":"reference/configuration/","title":"Reference","text":"<p>All the magic <code>kube-burner</code> does is described in its configuration file. As previously mentioned the location of this configuration file is provided by the flag <code>-c</code>. This flag points to a YAML formatted file that consists of several sections.</p> <p>It's possible to use go-template semantics within this configuration file, also it's important to note that every environment variable is passed to this template, so we can reference them using the syntax <code>{{.MY_ENV_VAR}}</code>. For example, we could define the <code>indexerConfig</code> section of our configuration file like:</p> <pre><code>enabled: true\ntype: elastic\nesServers: [{{ .ES_SERVER }}]\ndefaultIndex: elasticsearch-index\n</code></pre> <p>This feature can be very useful at the time of defining secrets such as the user and password of our indexer, or a token to use in pprof collection.</p>"},{"location":"reference/configuration/#global","title":"Global","text":"<p>In this section is described global job configuration, it holds the following parameters:</p> Option Description Type Default <code>measurements</code> List of measurements. Detailed in the measurements section List [] <code>indexerConfig</code> Holds the indexer configuration. Detailed in the indexers section Object {} <code>requestTimeout</code> Client-go request timeout Duration 15s <code>prometheusURL</code> Prometheus URL endpoint, flag has precedence String \"\" <code>bearerToken</code> Bearer token to access the Prometheus endpoint String \"\" <code>metricsProfile</code> Path to the metrics profile configuration file String \"\" <code>metricsEndpoint</code> Path to the metrics endpoint configuration file containing a list of target endpoints, flag has precedence String \"\" <code>GC</code> Garbage collect created namespaces Boolean false <p>kube-burner connects k8s clusters using the following methods in this order:</p> <ul> <li><code>KUBECONFIG</code> environment variable</li> <li><code>$HOME/.kube/config</code></li> <li>In-cluster config (Used when kube-burner runs inside a pod)</li> </ul>"},{"location":"reference/configuration/#jobs","title":"Jobs","text":"<p>This section contains the list of jobs <code>kube-burner</code> will execute. Each job can hold the following parameters.</p> Option Description Type Default <code>name</code> Job name String \"\" <code>jobType</code> Type of job to execute. More details at job types string create <code>jobIterations</code> How many times to execute the job Integer 0 <code>namespace</code> Namespace base name to use String \"\" <code>namespacedIterations</code> Whether to create a namespace per job iteration Boolean true <code>cleanup</code> Cleanup clean up old namespaces Boolean true <code>podWait</code> Wait for all pods to be running before moving forward to the next job iteration Boolean false <code>waitWhenFinished</code> Wait for all pods to be running when all iterations are completed Boolean true <code>maxWaitTimeout</code> Maximum wait timeout in seconds. (If podWait is enabled this timeout will be reseted with ) Integer 1h <code>jobIterationDelay</code> How long to wait between each job iteration Duration 0s <code>jobPause</code> How long to pause after finishing the job Duration 0s <code>qps</code> Limit object creation queries per second Integer 0 <code>burst</code> Maximum burst for throttle Integer 0 <code>objects</code> List of objects the job will create. Detailed on the objects section List [] <code>verifyObjects</code> Verify object count after running each job Boolean true <code>errorOnVerify</code> Set RC to 1 when objects verification fails Boolean true <code>preLoadImages</code> Kube-burner will create a DS before triggering the job to pull all the images of the job true true <code>preLoadPeriod</code> How long to wait for the preload daemonset Duration 1m <code>namespaceLabels</code> Add custom labels to the namespaces created by kube-burner Object {} <code>churn</code> Churn the workload. Only supports namespace based workloads Boolean false <code>churnPercent</code> Percentage of the jobIterations to churn each period Integer 10 <code>churnDuration</code> Length of time that the job is churned for Duration 1h <code>churnDelay</code> Length of time to wait between each churn period Duration 5m <p>Examples of valid configuration files can be found at the examples folder.</p>"},{"location":"reference/configuration/#objects","title":"Objects","text":"<p>The objects created by <code>kube-burner</code> are rendered using the default golang's template library. Each object element supports the following parameters:</p> Option Description Type Default <code>objectTemplate</code> Object template file path or URL String \"\" <code>replicas</code> How replicas of this object to create per job iteration Integer - <code>inputVars</code> Map of arbitrary input variables to inject to the object template Object - <code>namespaced</code> Whether to create a namespaced object or not Boolean true <code>wait</code> Wait for object to be ready Boolean true <code>waitOptions</code> Customize how to wait for object to be ready Object {} <p>Warning</p> <p>Kube-burner is only able to wait for a subset of resources, unless <code>waitOptions</code> are specified.</p> <p>Info</p> <p>Find more info about the waiters implementation in the <code>pkg/burner/waiters.go</code> file</p>"},{"location":"reference/configuration/#wait-options","title":"Wait Options","text":"<p>If you want to override the default waiter behaviors, you can specify wait options for your objects.</p> Option Description Type Default <code>forCondition</code> Wait for the object condition with this name to be true String \"\" <p>For example, the snippet below can be used to make kube-burner to wait for all containers from the pod defined at <code>pod.yml</code> to be ready</p> <pre><code>objects:\n- objectTemplate: pod.yml\nreplicas: 3\nwaitOptions:\nforCondition: Ready\n</code></pre>"},{"location":"reference/configuration/#default-labels","title":"Default labels","text":"<p>All objects created by kube-burner are labeled with. <code>kube-burner-uuid=&lt;UUID&gt;,kube-burner-job=&lt;jobName&gt;,kube-burner-index=&lt;objectIndex&gt;</code>. They are used for internal purposes but they can also be used by the users.</p>"},{"location":"reference/configuration/#job-types","title":"Job types","text":"<p>Configured by the parameter <code>jobType</code>, kube-burner support three types of jobs with different parameters each,</p>"},{"location":"reference/configuration/#create","title":"Create","text":"<p>The default <code>jobType</code> is create. Which basically creates objects listed in the <code>objects</code> parameter as described in the objects section.</p>"},{"location":"reference/configuration/#delete","title":"Delete","text":"<p>This type of job deletes objects described in the objects list. Using delete as job type the objects list would have the following structure:</p> <pre><code>objects:\n- kind: Deployment\nlabelSelector: {kube-burner-job: cluster-density}\napiVersion: apps/v1\n\n- kind: Secret\nlabelSelector: {kube-burner-job: cluster-density}\n</code></pre> <p>Where:</p> <ul> <li><code>kind</code>: Object kind of the k8s object to delete.</li> <li><code>labelSelector</code>: Deletes the objects with the given labels.</li> <li><code>apiVersion</code>: API version from the k8s object.</li> </ul> <p>This type of job supports the following parameters (some of them already described in the the create job type section):</p> <ul> <li><code>waitForDeletion</code>: Wait for objects to be deleted before finishing the job. Defaults to true</li> <li><code>name</code></li> <li><code>qps</code></li> <li><code>burst</code></li> <li><code>jobPause</code></li> <li><code>jobIterationDelay</code></li> </ul>"},{"location":"reference/configuration/#patch","title":"Patch","text":"<p>This type of jobs can be used to patch objects with the template described in the object list. This object list has the following structure:</p> <pre><code>objects:\n- kind: Deployment\nlabelSelector: {kube-burner-job: cluster-density}\nobjectTemplate: templates/deployment_patch_add_label.json\npatchType: \"application/strategic-merge-patch+json\"\napiVersion: apps/v1s\n</code></pre> <p>Where:</p> <ul> <li><code>kind</code>: Object kind of the k8s object to patch.</li> <li><code>labelSelector</code>: Map with the labelSelector.</li> <li><code>objectTemplate</code>: The YAML template or JSON file to patch.</li> <li><code>apiVersion</code>: API version from the k8s object.</li> <li><code>patchType</code>: The kubernetes request patch type (see below).</li> </ul> <p>Valid patch types:</p> <ul> <li>application/json-patch+json</li> <li>application/merge-patch+json</li> <li>application/strategic-merge-patch+json</li> <li>application/apply-patch+yaml (requires YAML)</li> </ul> <p>As mentioned previously, all objects created by kube-burner are labeled with <code>kube-burner-uuid=&lt;UUID&gt;,kube-burner-job=&lt;jobName&gt;,kube-burner-index=&lt;objectIndex&gt;</code>. Thanks to this we could design a workload with one job to create objects and another one able to patch or remove the objects created by the previous</p> <pre><code>jobs:\n- name: create-objects\nnamespace: job-namespace\njobIterations: 100\nobjects:\n- objectTemplate: deployment.yml\nreplicas: 10\n\n- objectTemplate: service.yml\nreplicas: 10\n\n- name: remove-objects\njobType: delete\nobjects:\n- kind: Deployment\nlabelSelector: {kube-burner-job: create-objects}\napiVersion: apps/v1\n\n- kind: Secret\nlabelSelector: {kube-burner-job: create-objects}\n</code></pre>"},{"location":"reference/configuration/#churning-jobs","title":"Churning Jobs","text":"<p>Churn is the deletion and re-creation of objects and is supported for namespace based jobs only. This occurs after the job has completed but prior to uploading metrics, if applicable. It deletes a percentage of contiguous namespaces randomly chosen and re-creates them with all of the appropriate objects. It will then wait for a specified delay (or none if set to 0) before deleting and recreating the next randomly chosen set. This cycle continues until the churn duration has passed.</p> <p>An example implementation that would churn 20% of the 100 job iterations for 2 hours with no delay between sets:</p> <pre><code>jobs:\n- name: cluster-density\njobIterations: 100\nnamespacedIterations: true\nnamespace: churning\nchurn: true\nchurnPercent: 20\nchurnDuration: 2h\nchurnDelay: 0s\nobjects:\n- objectTemplate: deployment.yml\nreplicas: 10\n\n- objectTemplate: service.yml\nreplicas: 10\n</code></pre>"},{"location":"reference/configuration/#injected-variables","title":"Injected variables","text":"<p>All object templates are injected the variables below by default</p> <ul> <li><code>Iteration</code>: Job iteration number.</li> <li><code>Replica</code>: Object replica number. Keep in mind that this number is reset to 1 with each job iteration.</li> <li><code>JobName</code>: Job name.</li> <li><code>UUID</code>: Benchmark UUID.</li> </ul> <p>In addition, you can also inject arbitrary variables with the option <code>inputVars</code> of the object:</p> <pre><code>- objectTemplate: service.yml\nreplicas: 2\ninputVars:\nport: 80\ntargetPort: 8080\n</code></pre> <p>The following code snippet shows an example of a k8s service using these variables:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nname: sleep-app-{{.Iteration}}-{{.Replica}}\nlabels:\nname: my-app-{{.Iteration}}-{{.Replica}}\nspec:\nselector:\napp: sleep-app-{{.Iteration}}-{{.Replica}}\nports:\n- name: serviceport\nprotocol: TCP\nport: \"{{.port}}\"\ntargetPort: \"{{.targetPort}}\"\ntype: ClusterIP\n</code></pre> <p>You can also use golang template semantics in your <code>objectTemplate</code> definitions</p> <pre><code>kind: ImageStream\napiVersion: image.openshift.io/v1\nmetadata:\nname: {{.prefix}}-{{.Replica}}\nspec:\n{{ if .image }}\ndockerImageRepository: {{.image}}\n{{ end }}\n</code></pre>"},{"location":"reference/configuration/#template-functions","title":"Template functions","text":"<p>In addition to the default golang template semantics, Kube-burner is compiled with the sprig library, which adds over 70 template functions for Go\u2019s template language.</p>"}]}